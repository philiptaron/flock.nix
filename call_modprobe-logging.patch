diff --git a/kernel/module/kmod.c b/kernel/module/kmod.c
index 0800d9891692..d884bfde79e6 100644
--- a/kernel/module/kmod.c
+++ b/kernel/module/kmod.c
@@ -63,8 +63,12 @@ static DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);
 */
 char modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;
 
-static void free_modprobe_argv(struct subprocess_info *info)
+static void finish_modprobe(struct subprocess_info *info)
 {
+	if (info->retval) {
+		pr_info("%s: %s %s %s %s failed: %d\n", __func__,
+			info->argv[0], info->argv[1], info->argv[2], info->argv[3], info->retval);
+	}
 	kfree(info->argv[3]); /* check call_modprobe() */
 	kfree(info->argv);
 }
@@ -92,15 +96,25 @@ static int call_modprobe(char *orig_module_name, int wait)
 	argv[0] = modprobe_path;
 	argv[1] = "-q";
 	argv[2] = "--";
-	argv[3] = module_name;	/* check free_modprobe_argv() */
+	argv[3] = module_name;	/* check finish_modprobe() */
 	argv[4] = NULL;
 
+	pr_info("%s: running %s %s %s %s\n", __func__, argv[0], argv[1], argv[2], argv[3]);
+
 	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,
-					 NULL, free_modprobe_argv, NULL);
-	if (!info)
+					 NULL, finish_modprobe, NULL);
+	if (!info) {
+		pr_info("%s: %s %s %s %s failed to call_usermodehelper_setup", __func__,
+			argv[0], argv[1], argv[2], argv[3]);
 		goto free_module_name;
+	}
 
 	ret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);
+	if (ret) {
+		pr_info("%s: %s %s %s %s failed: %d\n", __func__,
+			argv[0], argv[1], argv[2], argv[3], ret);
+	}
+
 	kmod_dup_request_announce(orig_module_name, ret);
 	return ret;
 
